import{_ as e,c as s,o as t,ag as i}from"./chunks/framework.DPDPlp3K.js";const k=JSON.parse('{"title":"React Base(基础)","description":"","frontmatter":{},"headers":[],"relativePath":"src/frontend/React/react-base.md","filePath":"src/frontend/React/react-base.md","lastUpdated":1737139361000}'),n={name:"src/frontend/React/react-base.md"};function l(r,a,c,o,p,d){return t(),s("div",null,a[0]||(a[0]=[i(`<h1 id="react-base-基础" tabindex="-1">React Base(基础) <a class="header-anchor" href="#react-base-基础" aria-label="Permalink to &quot;React Base(基础)&quot;">​</a></h1><h2 id="什么是-react" tabindex="-1">什么是 React？ <a class="header-anchor" href="#什么是-react" aria-label="Permalink to &quot;什么是 React？&quot;">​</a></h2><p>React 是一个用于构建用户界面的 JavaScript 库。它被设计用于构建 UI，并且可以轻松地与其他 JavaScript 框架配合使用。React 的核心思想是将 UI 的状态和行为抽象成一个组件，然后通过渲染这些组件来更新 UI。React 的组件化思想使得代码更容易理解和维护，并且可以更好地适应复杂的应用。</p><h2 id="为什么要使用-react" tabindex="-1">为什么要使用 React？ <a class="header-anchor" href="#为什么要使用-react" aria-label="Permalink to &quot;为什么要使用 React？&quot;">​</a></h2><p>React 的主要优点包括：</p><ul><li>声明式编程：React 使用声明式编程，这意味着你只需要描述你想要的结果，React 会自动更新 DOM 以反映这些结果。</li><li>组件化：React 将 UI 的状态和行为抽象成一个个组件，这使得代码更容易理解和维护。</li><li>虚拟 DOM：React 使用虚拟 DOM，这意味着 React 不会直接操作 DOM，而是创建一个虚拟的 DOM，然后再与真实的 DOM 进行比较，最后再将变化应用到真实的 DOM 上。</li><li>单向数据流：React 的单向数据流使得应用的状态变化更容易追踪，并且可以帮助你更好地理解应用的行为。</li></ul><h2 id="安装-react" tabindex="-1">安装 React <a class="header-anchor" href="#安装-react" aria-label="Permalink to &quot;安装 React&quot;">​</a></h2><p>React 可以用 npm 安装：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>npm install react react-dom</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>或者用 yarn 安装：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>yarn add react react-dom</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="第一个-react-组件" tabindex="-1">第一个 React 组件 <a class="header-anchor" href="#第一个-react-组件" aria-label="Permalink to &quot;第一个 React 组件&quot;">​</a></h2><p>下面是一个简单的 React 组件：</p><div class="language-jsx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Greeting</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Hello, world!&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Greeting;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这个组件是一个函数组件，它返回一个<code>h1</code>标签，里面包含了&quot;Hello, world!&quot;。这个组件可以被导入到其他组件中，然后在渲染时被渲染成一个<code>h1</code>标签。</p><h2 id="jsx" tabindex="-1">JSX <a class="header-anchor" href="#jsx" aria-label="Permalink to &quot;JSX&quot;">​</a></h2><p>JSX 是一种类似于 HTML 的语法扩展，它可以用来定义 React 组件的结构。JSX 代码会被编译成 JavaScript 代码，然后执行。JSX 的主要优点是可以将 HTML 和 JavaScript 代码混合在一起，使得代码更易于阅读和编写。</p><h2 id="组件的生命周期" tabindex="-1">组件的生命周期 <a class="header-anchor" href="#组件的生命周期" aria-label="Permalink to &quot;组件的生命周期&quot;">​</a></h2><p>React 组件有几个生命周期方法，它们会在组件的不同阶段被调用。这些方法包括：</p><ul><li><code>componentWillMount()</code>: 在组件挂载之前调用，在这个方法中可以进行一些准备工作，比如设置状态。</li><li><code>componentDidMount()</code>: 在组件挂载之后调用，在这个方法中可以进行一些初始化工作，比如获取数据。</li><li><code>componentWillReceiveProps(nextProps)</code>: 当组件接收到新的 props 时调用，在这个方法中可以根据新的 props 更新组件的状态。</li><li><code>shouldComponentUpdate(nextProps, nextState)</code>: 当组件接收到新的 props 或 state 时调用，在这个方法中可以返回<code>false</code>来阻止组件的更新。</li><li><code>componentWillUpdate(nextProps, nextState)</code>: 在组件更新之前调用，在这个方法中可以进行一些准备工作，比如保存当前的状态。</li><li><code>componentDidUpdate(prevProps, prevState)</code>: 在组件更新之后调用，在这个方法中可以进行一些更新后的工作，比如重新渲染子组件。</li><li><code>componentWillUnmount()</code>: 在组件卸载之前调用，在这个方法中可以进行一些清理工作，比如清除定时器。</li></ul><h2 id="react-router" tabindex="-1">React Router <a class="header-anchor" href="#react-router" aria-label="Permalink to &quot;React Router&quot;">​</a></h2><p>React Router 是一个用于构建单页应用的库，它可以帮助你管理应用的路由。React Router 的主要优点包括：</p><ul><li>声明式路由：React Router 使用声明式路由，这意味着你只需要描述你想要的路由，React Router 会自动处理路由的跳转和渲染。</li><li>动态路由：React Router 支持动态路由，这意味着你可以根据 URL 的不同来渲染不同的组件。</li><li>路由守卫：React Router 支持路由守卫，这意味着你可以在路由跳转之前进行一些验证，比如权限验证。</li></ul><h2 id="react-hooks" tabindex="-1">React Hooks <a class="header-anchor" href="#react-hooks" aria-label="Permalink to &quot;React Hooks&quot;">​</a></h2><p>React Hooks 是 React 16.8 版本引入的新特性，它可以让你在函数组件中使用状态和其他 React 特性，而无需使用 class。React Hooks 的主要优点包括：</p><ul><li>状态和生命周期：React Hooks 可以让你在函数组件中使用状态和生命周期，而无需使用 class。</li><li>自定义 Hook：React Hooks 可以让你创建自定义 Hook，这使得代码更易于组织和重用。</li><li>性能优化：React Hooks 可以让你在函数组件中避免不必要的渲染，这可以提高应用的性能。</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>React 是一个用于构建用户界面的 JavaScript 库，它提供了声明式编程、组件化、虚拟 DOM、单向数据流等优点。React 的安装、组件、JSX、组件生命周期、React Router、React Hooks 等内容将会在后续的文章中详细介绍。</p>`,28)]))}const u=e(n,[["render",l]]);export{k as __pageData,u as default};
